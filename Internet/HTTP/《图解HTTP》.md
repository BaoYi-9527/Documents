[TOC]

## 《图解HTTP》

### 1. 了解Web及网络基础

#### 1.1 相关概念

+ 客户端(cilent)：通过发送请求获取服务器资源的Web浏览器等；

+ 借助多文档之间相互关联的形成的超文本，连成可相互参阅的WWW(World Wide Web，万维网)；

  三项WWW构建技术：HTML(超文本标记语言)、HTTP(文档传递协议)、URL(统一资源定位符)；

*HTTP通常被译为超文本传输协议，但这种译法并不严谨，严谨的译名应该为 “超文本转移协议”。*

#### 1.2 网络基础TCP/IP

通常使用的网络(包括互联网)实在TCP/IP协议簇的基础上运作的。而HTTP属于它内部的一个子集；

不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则，而我们就把这种规则称之为协议(protocol);

##### 1.2.1 TCP/IP的分层管理

TCP/IP协议族按层次分为4层：

+ 应用层：

  决定了向用户提供服务时通信的活动。

  TCP/IP协议族内预存了各类通用的应用服务(FTP/DNS等)。

  HTTP协议位于该层。

+ 传输层：

  对上层的应用层提供处于网络连接中的俩台计算机之间的数据传输。

  传输层存在俩个性质不同的协议：TCP(传输控制协议)和UDP(用户数据报协议)；

+ 网络层(又名网络互连层)：

  用于处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径(传输路线)到达对方计算机，并将数据包传送给对方；

  与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。

+ 链路层(又名数据链路层，网络接口层)：

  用于处理连接网络的硬件部分。包括控制系统、硬件的设备驱动、NIC、及光纤等物理可见部分。



*PS：TCP和UDP的区别*

|            | UDP                                      | TCP                                  |
| ---------- | ---------------------------------------- | ------------------------------------ |
| 是否连接   | 无连接                                   | 面向连接                             |
| 是否可靠   | 不可靠传输，不使用流量控制和拥塞控制     | 可靠传输，使用流量控制和拥塞控制     |
| 连接对象数 | 支持一对一、一对多、多对一和多对多通信   | 仅支持一对一                         |
| 传输方式   | 面向报文                                 | 面向字节流                           |
| 首部开销   | 首部开销小，仅8字节                      | 首部开销最小20字节，最大60字节       |
| 适用场景   | 适用于实时应用(IP电话、视频会议、直播等) | 适用于要求可靠性的应用、例如文件传输 |

> 总结：
>
> + TCP向上层提供面向连接的可靠服务，UDP向上层提供无连接的不可靠服务；
> + 虽然UDP没有TCP传输来的准确，但是也能在很多实时性要求高的地方有所作为；
> + 对数据的准确性要求高，速度可以相对较慢的，选择TCP；

##### 1.2.2 TCP/IP 通信传输流

利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层网上走。

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部信息消去。这种数据信息包装起来的做法称之为封装(encapsulate)。

<img src="D:\wamp\www\hello-world\HTTP\imgs\TCP_IP.jpg" alt="TCP_IP" style="zoom: 50%;" />

#### 1.3 与HTTP关系密切的协议：IP、TCP和DNS

**IP 网络协议：**

该协议位于网络层，其作用是将各种数据包传送给对方。而要保证确实传送到了对方那里，则需要满足各类条件。其中最重要的条件是IP地址和MAC地址。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会更改。

*ARP协议：一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。*

*在到达通信目标前的中转过程中，哪些计算机和路由器等网络设备只能获悉很粗略的传输路线。*

**TCP协议：**

TCP位于传输层，提供可靠的字节流服务。所谓的字节流服务，为了方便传输，将大块的数据分隔成报文段(segment)为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传递给对方。

> 为了准确无误的将数据送达目标处，TCP协议采用了三次握手策略。握手过程中使用了TCP的标志SYN和ACK。
>
> + 没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。
>
> + 发送端首先发送一个带有SYN标志的数据包给对方。接收端受到后回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议将会再次以相同的顺序发送相同的数据包。
>
> *TCP断开需要四次：*
>
> + 第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；
>
> + 第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；
>
> + 第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；
>
> + 第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。



**负责域名解析的DNS服务：**

该服务和HTTP协议一样位于应用层，它提供域名到IP地址之间的解析服务。DNS协议提供域名查找IP地址，或逆向从IP地址反查域名的服务。

#### 1.4 URI与URL

URI(统一资源标识符)、URL(统一资源定位符)。

URL是Web浏览器等访问Web页面时需要输入的网页地址。

URI是用字符串标识某一互联网资源，而URL则标识资源的地点(互联网上的位置)。即URL是URI的子集。

***

### 2. 简单的HTTP协议

#### 2.1 简介

1. HTTP协议用于客户端和服务器端之间的通信：

   请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。

   所以一台计算机可以是客户端也可以是服务器端，但仅从一条通信线路上来说，服务器端和客户端的角色是确定的。

2. 通过请求和响应的交换达成通信

   HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。

   请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。

   响应报文基本上由协议版本、状态码(表示请求成功或失败的数字)、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

3. HTTP 是不保存状态的协议

   HTTP是一种不保存状态，即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。

   这样设计的目的是为了更快地处理大量的事务，确保协议的可伸缩性。

   HTTP协议通信的状态管理可以通过Cookie实现，见后续。

4. 请求URI定位资源

   HTTP协议使用URI定位互联网上的资源。当客户端请求访问资源而发送请求时，URI需要将请求报文中的请求URI包含在内。

5. 告知服务器意图的HTTP方法

   



**HTTP方法：**

+ GET：获取资源

  GET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应内容。

+ POST：传输实体主体

+ PUT：传输文件

+ HEAD：获得报文首部，不返回报文主体部分，用于确认URI的有效性以及资源更新的日期时间等

+ DELETE：删除文件

+ OPTIONS：查询针对请求URI指定的资源支持的方法

+ TRACE：让Web服务器端将之前的请求通信换回给客户端

+ CONNECT：要求使用隧道协议连接代理

>1. 鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用PUT和DELETE方法。若配合Web应用程序的验证机制，或架构采用REST(表征状态转移)标准的同类Web网站，就可能开放这个俩个方法。
>
>2. TRACE方法在发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。TRACE方法用来确认连接过程中发生的一系列操作，但不常用，切该方法易引发XST(跨站追踪)攻击。
>3.  CONNECT方法要求在于代理服务通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL(安全套接层)和TLS(传输层安全)协议把通信内容加密后经网络隧道传输。

#### 2.2 持久连接节省通信量

HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。这样导致在同一个客户端对服务器端进行大量的请求时，大量的无谓的TCP连接建立和断开增加了不必要的开销。

##### 2.2.1 持久连接

HTTP/1.1和一部分的HTTP/1.0想出了持久连接(也称为keep-alive或HTTP connection reuse)的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

持久连接旨在建立一次TCP连接后进行多次请求和响应的交互。

持久连接的好处在于减少了TCP连接的重复建立和断开所造成的的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使得HTTP请求和响应能够更早的结束，这样Web页面的显示速度也就相应提高了。

在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化。

##### 2.2.2 管线化

持久连接使得多数请求以管线化(pipelining)方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求，即可同时并行发送多个请求。

#### 2.2.3 Cookie的状态管理

HTTP作为无状态的协议，由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。

Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie会根据从服务器发送的响应报文中的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie 。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

***

### 3. HTTP报文内的HTTP信息

#### 3.1 HTTP报文

用于HTTP协议交互的信息被称为HTTP报文。请求端(客户端)的HTTP报文叫做请求报文，响应端(服务器端)的叫做响应报文。HTTP报文本身是由多行数据构成的字符串文本。

HTTP报文大致可分为报文首部和报文主体俩部分。

#### 3.2 请求报文及响应报文的结构

<img src="D:\2021\img\请求_响应报文.jpg" alt="请求_响应报文" style="zoom:50%;" />

+ 请求行：包含用于请求的方法，请求URI和HTTP版本；

+ 状态行：包含表明响应结果的状态码，原因短语和HTTP版本；

+ 首部字段：包含表示请求和响应的各种条件和属性的各类首部。

  一般有4种首部：通用首部、请求首部、响应首部、实体首部。

+ 其他：可能包含HTTP的RFC里未定义的首部(Cookie等)。

#### 3.3 编码提升传输速率

HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。

通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU资源。

##### 3.3.1 报文主体和实体主体的差异

+ 报文(message)

  HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输。

+ 实体(entity)

  作为请求和响应的有效载荷数据(补充项)被传输，其内容由实体首部和实体主体组成。

*HTTP报文的主体用于传输请求或响应的实体主体。*

##### 3.3.2 压缩传输的内容编码

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。

*常见的内容编码：*

+ gzip(GNU zip)
+ compress(UNIX 系统的标准压缩)
+ deflate(zlib)
+ identity(不进行编码)

##### 3.3.3 分割发送的分块传输编码

在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种将实体主体分块的功能称为分块传输编码.

分块传输编码会将实体主体分成多个部分(块)。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用 "0(CR+LF)" 来标记。

HTTP/1.1 中存在一种称为传输编码的机制，它可以在通信时按某种编码方式传输，当只定义作用于分块传输编码中。

#### 3.4 发送多种数据的多部分对象集合

邮件传输中MIME机制(多用途邮件扩展)，它允许邮件处理文本、图片、视频等多个不同类型的数据。

MIME中使用了一种称为多部分对象集合的方法，来容纳多分不同类型的数据。

而HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本等上传时使用。

*多部分对象集合包含对象如下*：

+ multipart/form-data

  在web表单文件上传时使用。

+ multipart/byteranges

  状态码206(部分内容)响应报文包含多个范围的内容时使用。

在HTTP报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。

使用 boundary 字符串来划分多部分对象集合指明的各类实体。boundary 字符串中的各个实体起始行和结尾处都会插入 "--"标记。

多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分嵌套使用多部分对象集合。

#### 3.5 获取部分内容的范围请求

指定数据的一部分进行请求(指定范围发送请求)叫做范围请求。

执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。

针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 表明 multipart/byteranges 后返回响应报文。

如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。

#### 3.6 内容协商返回最合适的内容

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

*判断基准(包含在请求报文中的某些首部字段)：*

+ Accept
+ Accept-Charset
+ Accept-Encoding
+ Accept-Language
+ Content-Language

*内容协商技术的三种类型：*

+ 服务器驱动协商

  有服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。

+ 客户端驱动协商

  由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。

+ 透明协商

  服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

***

### 4. 返回结果的HTTP状态码



#### 4.1 状态码告知从服务器端返回的请求结果

状态码的职责是当客户端想服务器端发送请求时，描述返回的请求结果。

*状态码的类别：*

|      | 类别                           | 原因短语                   |
| ---- | ------------------------------ | -------------------------- |
| 1XX  | Informational(信息性状态码)    | 接收的请求正在处理         |
| 2XX  | Success(成功状态码)            | 请求正常处理完毕           |
| 3XX  | Redirection(重定向状态码)      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error(客户端错误状态码) | 服务器无法处理请求         |
| 5XX  | Server Error(服务器错误状态码) | 服务器处理请求出错         |

 

#### 4.2 2XX 成功

##### 4.2.1 200 OK

表示从客户端发来的请求在服务器端被正常处理了。

在响应报文内，随着状态码一起返回的信息会因为方法的不同而发生改变。

##### 4.2.2 204 No Content

该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不包含实体的主体部分。另外也不允许返回任何实体的主体。

一般在只需要从客户端往服务器发送信息，而对客户端不需要发送信息内容的情况使用。

##### 4.2.3 206 Partial Content 

该状态码表示客户端进行范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由 Content-Range 指定范围的实体内容。

#### 4.3 3XX 重定向

3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

##### 4.3.1 301 Moved Permanently

永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指定的URI。

##### 4.3.2 302 FOUND

临时重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。

##### 4.3.3 303 See Other 

该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。

*303状态码和 302 Found 状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。*

> 虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视为303响应，并且使用GET方法访问在Location中规定的URI，而无视原先请求的方法。
>
> 当301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。但标准上是禁止这样做的。

##### 4.3.4 304 Not Modified

该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未满足条件的情况。

304状态码返回时，不包括任何响应的主体部分。304虽然被划分在 3XX 中，但是和重定向没有关系。

> 附带条件的请求：是指采用 GET 方法的请求报文中包含 If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部。

##### 4.3.5 Temporary Redirect

临时重定向。该状态码与 302 Found 有着相同的含义。

307 会遵循浏览器标准，不会从 POST 变成 GET 。但是对于处理响应时的行为，每种浏览器都有可能出现不同的情况。

#### 4.4 4XX 客户端错误

4XX 的响应结果表明客户端是发送错误的原因所在。

##### 4.4.1 400 Bad Request

该状态码表示请求报文中存在语法错误。当错误发送时，需修改请求的内容后再次发送请求。

##### 4.4.2 Unauthorized

该状态码表示发送的请求需要有通过HTTP认证的认证信息。

返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询用户信息。

##### 4.4.3 403 Forbidden

该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由。

也可以在实体的主体部分对原因进行描述。

##### 4.4.4 404 Not Found

该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

#### 4.5 5XX 服务器错误

5XX 的响应结果表明服务器本身发生错误。

##### 4.5.1 500 Internal Server Error

该状态码表明服务器在执行请求时发送了错误。也有可能时 Web 应用存在的 Bug 或某些临时的故障。

##### 4.5.2 503 Service Unaviailable

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

如果事先得知解除以上状况所需的时间，最好写入 Retry-After 首部字段再返回给客户端。

***

### 5. 与HTTP协作的Web服务器

#### 5.1 用单台虚拟主机实现多个域名

HTTP/1.1 规范允许一台HTTP服务器搭建多个Web站点。

即使物理层面只有一台服务器，但只要使用虚拟机的功能，则可以假想已具有多台服务器。

> 在相同的IP地址下，由于虚拟主机可以寄存多个不同的主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内部完整指定主机名或域名的URI。

#### 5.2 通信数据转发程序：代理、网关、隧道

这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。

##### 5.2.1 代理

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端 “中间人” 的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。

持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。

在HTTP通信过程中，可级联多台代理服务器，请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加 Via 首部字段以标记出经过的主机信息。

*使用代理服务器的理由：*

+ 减少网络带宽的流量；
+ 组织内部针对特定网站的访问控制；
+ 以获取访问日志为主要目的等。

*代理按俩种基准分类，一种是是否使用缓存，另一种是是否会修改报文。*

+ 缓存代理(Caching Proxy)：

  代理转发请求时，缓存代理会预先将资源的副本(缓存)保存在代理服务器上。

  当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

+ 透明代理(Transparent Proxy)：

  转发请求或响应时，不对报文做任何加工的代理类型称之为透明代理。反之，对报文内容进行加工的代理被称为非透明代理。

##### 5.2.2 网关

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。

网关的工作机制和代理十分类似。而网关能使通信线路上的服务器提供非HTTP协议服务。

利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。

##### 5.2.3 隧道

隧道是在相隔甚远的客户端和服务器俩者之间进行中转，并保持双方通信连接的应用程序。

隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全通信。

> 隧道本身不会去解析HTTP请求。也就是说，请求原样中转给之后的服务器。隧道会在通信双方断开连接时结束。
>
> 通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在。

#### 5.3 保存资源的缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。

缓存服务器是代理服务器的一种，并归类在缓存代理类型中。通俗易懂的说就是，当代理转发从服务器返回的响应时，代理服务器会保存资源的副本。

*缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求。*

##### 5.3.1 缓存的有效期

即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。

##### 5.3.2 客户端的缓存

缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。浏览器缓存如果有效，就不必再向服务器请求相同的资源，可以直接从本地磁盘内读取。



**HTTP出现之前的协议：**

+ FTP(File Transfer Protocol)：传输文件时使用的协议。

***

### 6. HTTP首部

#### 6.1 HTTP报文首部

HTTP协议的请求和响应报文中必定含有HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。

在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成。

在响应中，HTTP报文由HTTP版本、状态码(数字和原因短语)、HTTP首部字段三部分构成。

#### 6.2 HTTP首部

##### 6.2.1 HTTP首部字段传递重要信息

HTTP首部字段是构成HTTP报文的要素之一。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。

##### 6.2.2 HTTP首部字段结构

HTTP首部字段是由首部字段名和字段值构成的，中间用冒号“:”分隔。

字段值对应单个HTTP首部字段可以有多个值。

```http
Keep-Alive: timeout=15, max=100
```

##### 6.2.3 4种HTTP首部字段类型

1. 通用首部字段(General Header Fields)

   请求报文和响应报文双方都会使用的首部。

2. 请求首部字段(Request Header Fields)

   从客户端想服务器端发送请求报文时使用的首部。补充请求的附加内容、客户端信息、响应内容相关优先级等信息。

3. 响应首部字段(Response Header Fields)

   从服务器端想客户端返回响应报文时使用的首部。补充响应的附加内容，也会要求客户端附加额外的内容信息。

4. 实体首部字段(Entity Header Fields)

   针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间与实体有关信息。

##### 6.2.4 HTTP/1.1 首部字段一览

**通用首部字段**

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码格式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Waring            | 错误通知                   |

**请求首部字段**

| 首部字段            | 说明                                          |
| ------------------- | --------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                      |
| Accept-Charset      | 优先的字符集                                  |
| Accept-Encoding     | 优先的内容编码                                |
| Accept-Language     | 优先的语言(自然语言)                          |
| Authorization       | Web认证信息                                   |
| Expect              | 期待服务器的特定行为                          |
| From                | 用户的电子邮箱地址                            |
| Host                | 请求资源所在服务器                            |
| If-Match            | 比较实体标记(ETag)                            |
| If-Modified-Since   | 比较资源的更新时间                            |
| If-None-Match       | 比较实体标记(与 If-Match 相反)                |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求          |
| If-Unmodified-Since | 比较资源的更新时间(与 If-Modified-Since 相反) |
| Max-Forwards        | 最大传输逐跳数                                |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                |
| Range               | 实体的字节范围请求                            |
| Referer             | 对请求中URI的原始获取方                       |
| TE                  | 传输编码的优先级                              |
| User-Agent          | HTTP客户端程序的信息                          |

**响应首部字段**

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| Etag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定URI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器的缓存的管理信息   |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

**实体首部字段**

| 首部字段名       | 说明                       |
| ---------------- | -------------------------- |
| Allow            | 资源可支持的HTTP方法       |
| Content-Encoding | 实体支持适用的编码方式     |
| Content-Language | 实体主体的自然语言         |
| Content-Length   | 实体主体的大小(单位：字节) |
| Content-Location | 替代对应资源的URI          |
| Content-MD5      | 实体主体的报文摘要         |
| Content-Range    | 实体主体的位置范围         |
| Content-Type     | 实体主体的媒体类型         |
| Expires          | 实体主体过期的日期时间     |
| Last-Modified    | 资源的最后修改日期时间     |

##### 6.2.5 非HTTP/1.1 首部字段

+ Cookie：
+ Set-Cookie：
+ Content-Disposition：

##### 6.2.6 End-to-end 首部和 Hop-by-Hop 首部

HTTP首部字段将定义成缓存代理和非缓存代理的行为，分为俩种：

+ 端到端首部(End-to-end Header)

  分在此类别的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。

+ 逐跳首部(Hop-by-hop Header)

  分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后的版本中，如果要使用 hop-by-hop 首部需提供 Connection 首部字段。

*列举HTTP/1.1 中的逐跳首部字段。除这8个首部字段之外，其他所有字段都属于端到端首部。*

+ Connection
+ Keep-Alive
+ Proxy-Authenticate
+ Proxy-Authorization
+ Trailer
+ TE
+ Transfer-Encoding
+ Upgrate

#### 6.3 为 Cookie 服务的首部字段

Cookie 的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie。

调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因为来自其他 Web 站点和攻击者的攻击而泄露。

| 首部字段名 | 说明                             | 首部类型     |
| ---------- | -------------------------------- | ------------ |
| Set-Cookie | 开始状态管理所使用的 Cookie 信息 | 响应首部字段 |
| Cookie     | 服务器接收到的 Cookie 信息       | 请求首部字段 |

##### 6.3.1 Set-Cookie

当服务器准备开始管理客户端的状态时，会实现告知各种信息。

*Set-Cookie 字段属性：*

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NAME=VALUE   | 赋予 Cookie 的名称和其值(必需项)                             |
| expires=DATE | Cookie 的有效期(若不明确指定则默认为浏览器关闭前为止)        |
| path=PATH    | 将服务器上的文件目录作为 Cookie 的适用对象(若不指定则默认为文档所在的文件目录) |
| domain=域名  | 作为 Cookie 适用对象的域名(若不指定则默认为创建 Cookie 的服务器的域名) |
| Secure       | 仅在HTTPS安全通信时才会发送 Cookie                           |
| HttpOnly     | 加以限制，使 Cookie 不能被 JavaScript 脚本访问。主要目的是为了防止跨站脚本攻击(XSS)对 Cookie 的信息窃取。 |

##### 6.3.2 Cookie

首部字段 Cookie 会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。

#### 6.4 其他首部字段

+ X-Frame-Options：

  HTTP响应首部，用于控制网站内容在其他Web网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持攻击。

+ X-XSS-Protection：

  HTTP响应首部，针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器XSS防护机制的开关。

+ DNT：

  HTTP请求首部，拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。

+ P3P：

  HTTP响应首部，利用P3P(在线隐私偏好平台)技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。

***

### 7. 确保Web安全的HTTPS

#### 7.1 HTTP的缺点

##### 7.1.1 通信使用明文可能会被窃听

由于HTTP本身不具备加密的功能，所以无法做到对通信整体(使用HTTP协议通信的请求和响应的内容)进行加密。即，HTTP报文使用明文(指未经过加密的报文)方式发送。

*TCP/IP是可能被窃听的网络。*

按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。

**加密处理防止被窃听：**

1. 通信的加密：

   HTTP协议中没有加密机制，但可以通过和SSL(安全套接层)或TLS(安全层传输协议)的组合使用，加密HTTP的通信内容。

   用SSL建立安全通信线路后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS(超文本传输安全协议)。

2. 内容的加密：

   对HTTP协议传输的内容本身进行加密。即，将HTTP报文里所含的内容进行加密处理。

   前提是要求客户端和服务器端同时具备加密和解密机制。主要应用于Web服务中。由于该方式不同于SSL或TLS将整个通信线路进行加密处理，所以内容仍有被篡改的风险。

##### 7.1.2 不验证通信方的身份就可能遭遇伪装

HTTP协议中的请求和响应不会对通信方进行确认。

不确认通信方会有如下隐患：

+ 无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器；
+ 无法确定响应返回的客户端是否是按真实意图接收响应的那个客户端；
+ 无法确定正在通信的对方是否具备访问权限；
+ 无法判断请求来自何方，出自谁手；
+ 即使是无意义的请求也会接收。即，无法阻止海量请求下得DoS攻击(拒绝服务攻击)。

**解决方案：**

查明对方的证书：证书是由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。通过确认通信方(服务器或客户端)持有的证书，即可判断通信方的真实意图。

##### 7.1.3 无法证明报文的完整性，可能已遭篡改

所谓的完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。

即，没有任何办法确认，发出的请求/响应和接收到的请求/响应时前后相同的。

请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击(MITM)。

**解决方案：**

常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。

但这些方法都无法由客户端自动帮用户检查。所以有必要使用HTTPS。SSL提供认证和加密处理以及摘要功能。

#### 7.2 HTTP + 加密 + 认证 + 完整性保护 = HTTPS

##### 7.2.1 HTTPS是身披SSL外壳的HTTP

HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。

通常HTTP直接和TCP通信。加上SSL后，则演变为先和SSL通信，再由SSL和TCP通信。

SSL是独立于HTTP的协议，不仅是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。

##### 7.2.2 相互交换密钥的公开密钥的加密技术

*SSL采用一种叫做公开密钥加密的加密处理方式。*

加密和解密用同一个密钥的方式称之共享密钥加密，也叫作对称密钥加密。

但由于密钥在传输、转发的过程中无法保证安全性，从而失去了加密的意义。

而公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，一把叫做公开密钥。

使用公开密钥加密的方式，发送密文的一方使用对方的公开密钥进行加密处理，对方受到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

**HTTPS采用混合加密机制：**

HTTPS采用共享密钥加密和公开密钥加密俩者并用的混合加密机制。

由于公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用俩者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

##### 7.2.3 证明公开密钥正确的证书

公开密钥加密技术存在一些问题，即无法证明公开密钥本身就是货真价实的公开密钥。

解决方法是使用数字证书认证机构和其相关机关颁发的公开密钥证书。

##### 7.2.4 HTTPS的安全通信机制

*HTTPS通信步骤：*

1. 客户端发送 Cilent Hello 报文开始 SSL通信。报文中包含客户端支持的SSL指定版本、加密组件列表等。
2. 服务器可进行SSL通信时，会以 Server Hello 报文作为应答。同样报文中包含SSL版本以及加密组件列表。服务器的加密组件列表内容格式从接收到的客户端加密组件列表内筛选出来的。
3. 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
4. 最后服务器发送 Server Hello Done 报文通知客户端。最初阶段的 SSL 握手协商部分结束。
5. SSL 第一次握手结束后，客户端以 Cilent Key Exchange 报文作为回应。报文中包含通信加密使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤3中的公开密钥进行加密。
6. 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
7. 客户端发送 Finished 报文。该报文包含连续至今全部报文的整体校验值。这次握手是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
8. 服务器同样发送 Change Cipher Spec 报文。
9. 服务器同样发送 Finished 报文。
10. 服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成，当然，通信会受到SSL的保护。从此处开始应用层协议的通信，即发送HTTP请求。
11. 应用层协议通信，即发送HTTP请求。
12. 最后由客户端断开连接。断开连接时，发送 close_notify 报文。这步之后再发送 TCP FIN 报文来关闭与TCP的通信。

*以上流程中，应用层发送数据时会附加一种叫做MAC的报文摘要。MAC能够查知报文是否遭到篡改从而保护报文的完整性。*

**SSL速度慢：**

HTTPS使用SSL，在处理速度上会变慢。

由于HTTPS还需要做服务器、客户端双方加密及解密处理，因此会消耗CPU和内存等硬件资源。

SSL的慢分为俩种。一种是指通信慢(额外的SSL通信)，另一种是指由于大量消耗CPU及内存等资源，导致处理速度变慢。

针对速度变慢的问题，没有根本性的解决方案，但可以使用SSL加速器(专用服务器)硬件来改善该问题。

*由于HTTPS与纯文本通信相比会消耗更多的CPU及内存资源。因此如果是非敏感信息则使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。*

***

### 8. 确认访问用户身份的认证

#### 8.1 认证

计算机本身无法判断使用者的身份，因此就需要核对一些信息确认用户身份：

+ 密码：用户本人知道的字符串信息；
+ 动态令牌：仅限用户持有的设备内显示的一次性密码；
+ 数字证书：仅限用户(终端)持有的信息；
+ 生物认证：指纹和虹膜等本人的生理信息；
+ IC卡等；

HTTP/1.1 使用的认证方式：

+ BASIC认证(基本认证)；
+ DIGEST认证(摘要认证)；
+ SSL客户端认证；
+ FormBase认证(基于表单认证)；

#### 8.2 BASIC认证

HTTP/1.0 就定义的认证方式。

BASIC认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后解释用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高。

#### 8.3 DIGEST认证

DIGEST 认证同样使用质询/响应的方式，但不会想BASIC认证那样直接发送明文密码。

*所谓质询响应是指，一开始一方会先发送认证要求给另一方，接着使用从另一方接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。*

DIGEST认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比人就很弱。DIGEST认证提供防止密码被窃听的保护机制，但并不存在用户伪装的保护机制。

#### 8.4 SSL客户端认证

SSL客户端认证时借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自自己登录的客户端。

*SSL客户端认证采用双因素认证：*

大多数情况下，SSL客户端不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证来使用。

所谓双因素认证是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。

即第一个认证因素的SSL客户端证书用来认证客户端计算机，另一个认证因素的密码用来确认这是用户本人的行为。

#### 8.5 基于表单认证

基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登录信息，按登录信息的验证结果认证。

*认证多半为基于表单认证。*

*Session管理以及Cookie应用。*

基于表单认证本身是用过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。

鉴于HTTP是无状态协议，之前认证的成功的用户无法通过协议层面保存下来。即，无法实现状态管理。因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie来管理Session，以弥补HTTP协议中不存在的状态管理功能。

*Session管理和Cookie状态管理：*

1. 客户端将用户ID和密码等登录信息放入报文实体部分，通常是以POST方法把请求发送给服务器。(使用HTTPS通信)
2. 服务器会发放用以识别该用户的 Session ID。通过验证客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID 。
3. 客户端接收到从服务器端发送来的 Session ID后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie ，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID识别用户和其认证状态。

> Session ID 必须是难以推测色字符串，且服务器需要进行有效期的管理，以保证其安全性。另外，为了减轻跨站脚本攻击(XSS)造成的损失，建议事先在 Cookie 内加上 httponly 属性。

不仅基于表单认证的登录信息及认证过程都无标准化的方法，服务器端应如何保存用户提交的密码等登录信息也没有标准化。

一种安全的方法是，先利用给密码加盐(salt)的方式增加额外信息，再使用散列值(hash)函数计算出散列值后保存。

> salt 其实就是有服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正的随机生成的。然后把它和密码字符串相连接生成散列值，当俩个用户使用了同一个密码时，由于随机生成的 salt 值不同，对应的散列值也将是不同的。这样一来，很大程度少减少了密码特征，攻击者也很难利用自己手中的密码特征库进行破解。

***

### 9. 基于HTTP的功能追加协议

#### 9.1 消除HTTP瓶颈的SPDY

解决HTTP的性能瓶颈，缩短Web页面的加载时间。

*HTTP标准产生的性能瓶颈：*

+ 一条连接上只可发送一个请求；
+ 请求只能从客户端开始。客户端不可用接收除响应以外的指令；
+ 请求/响应首部未经压缩就发送。首部信息越多延迟越大；
+ 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
+ 可任意选择数据压缩格式。非强制压缩发送。

**Ajax的解决方案：**

异步 JavaScript 与 XML 技术是一种有效利用 JavaScript 和 DOM 的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

Ajax 的核心技术名为 XMLHttpRequest 的 API ，通过JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。

然而利用 Ajax 实时从服务器获取内容，有可能会产生大量请求产生。

**Comet的解决方案：**

一旦服务器端有内容更新，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送(Server Push)的功能。

Comet 会在服务器接收到请求后，先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器一旦有更新，就可以立即反馈给客户端。

Comet 虽然做到了实时更新，但为了保留响应，一次连接的持续时间也变长了。等待响应期间为了维持连接会消耗更多的资源。

**SPDY的设计与功能：**

SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。

SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法、Cookie 以及 HTTP 报文等。

*SPDY的优点：*

+ 多路复用流

  通过单一的TCP连接，可以无限制处理多个HTTP请求。

+ 赋予请求优先级

  SPDY 可以给请求逐个分配优先级顺序。

+ 压缩HTTP首部

  压缩HTTP请求和响应首部，使通信产生的数据包流量和发送的字节数更少。

+ 推送服务

  支持服务器主动向客户端推送数据的功能。

+ 服务器提示功能

  服务器可以主动提示客户端请求所需资源。

*关于SPDY：*

1. SPDY基本上只是将单个域名(IP地址)的通信多路复用，所以当一个Web网站上使用多个域名下得资源时，改善效果就会受到限制。
2. SPDY的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非是由 HTTP 瓶颈所导致的。

#### 9.2 使用浏览器进行全双工通信的 WebSocket

##### 9.2.1 WebSocket 协议

WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。

一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都会依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML或图片等任意格式的数据。

由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

*WebSocket的主要特点：*

+ 推送功能

  支持由服务器向客户端推送数据的推送功能。

+ 减少通信量

  只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少了，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。

为了实现 WebSocket 通信，在 HTTP 连接建立后，需要完成一次 "握手" 操作。

**握手·请求**

为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。

Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol 字段内记录使用的子协议。

子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接的名称。

**握手·响应**

对于之前的请求，返回状态码 101 Switching Protocols 的响应。

Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。

成功握手确立 WebSocket 连接后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。

#### 9.3 HTTP/2.0

HTTP/2.0 的实现方法：

+ SPDY

+ HTTP Speed + Mobility 

  用于改善并提高移动端通信时的通信速度和性能的标准。

+ Network-Friendly HTTP Upgrate

  在移动端通信时改善 HTTP 性能的标准。

**HTTP/2.0 的七项技术及讨论：**

| 技术                  | 实现方法                    |
| --------------------- | --------------------------- |
| 压缩                  | SPDY、Friendly              |
| 多路复用              | SPDY                        |
| TLS义务化             | Speed + Mobility            |
| 协商                  | Speed + Mobility ，Friendly |
| 客户端拉曳/服务器推送 | Speed + Mobility            |
| 流量控制              | SPDY                        |
| WebSocket             | Speed + Mobility            |

#### 9.4 Web服务器管理文件的 WebDAV

WebDAV，基于万维网的分布式创作和版本控制，是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。

除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。

##### 9.4.1 扩展HTTP/1.1 的WebDAV

+ 集合：是一种统一管理多个资源的概念。
+ 资源：把文件或集合称为资源。
+ 属性：定义资源的属性。
+ 锁：把文件设置成无法编辑的状态。

##### 9.4.2 WebDAV 内新增的方法及状态码

WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了一下方法：

+ PROPFIND：获取属性
+ PROPPATCH：修改属性
+ MKCOL：创建集合
+ COPY：复制资源及属性
+ MOVE：移动资源
+ LOCK：资源加载
+ UNLOCK：资源解锁

为了配合扩展的方法，状态码也随之扩展：

+ 102 Processing：可正常处理请求，但目前是处理中的状态
+ 207 Muti-Status：存在多种状态
+ 422 Unprocessible Enity：格式正确，内容有误
+ 423 Locked：资源已被加锁
+ 424 Failed Dependency：处理与某请求关联的请求失败，因此不再维持依赖关系
+ 507 Insufficient Storage：保存空间不足

### 10. Web攻击技术

*PS: 原 第10章 "构建Web内容的技术" 只是对一些构建技术的介绍，在此略过。*

#### 10.1 针对 Web 的攻击技术

简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击对象。应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标。

##### 10.1.1 HTTP 不具备必要的安全功能

几乎所有的 Web 网站都会使用会话(session)管理、加密处理等安全性方面的功能，而 HTTP 协议内并不具备这些内容。

因此开发者需要自行设计并开发认证及会话管理功能来满足 Web 应用的安全。自行设计就意味着可能会出现安全漏洞。

##### 10.1.2 在客户端即可篡改请求

在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容、都可以在客户端自由的变更、篡改。所以 Web 应用可能会接收到与预期数据不相同的内容。

在 HTTP 请求报文中加载攻击代码，就能发起对 Web 应用的攻击。通过 URL 查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内容信息就会遭到窃取，或被攻击者拿到管理权限。

##### 10.1.3 针对 Web 应用的攻击模式

**以服务器为目标的主动攻击：**

主动攻击(active attack)是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。

*主动攻击模式具有代表性的攻击是 SQL注入攻击 和 OS命令注入攻击。*

**以服务器为目标的被动攻击：**

被动攻击(passice attack)是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访问发起攻击。

#### 10.2 因输出值转义不完全引发的安全漏洞

实施 Web 应用的安全对策大致分为俩个部分：

+ 客户端的验证
+ Web 应用端(服务器端)的验证
  + 输入值验证
  + 输出值转义

多数情况下采用 JavaScript 在客户端验证数据。由于客户端允许篡改数据或关闭 JavaScript，不适合将 JavaScript 验证作为安全的防范对策。保留客户端验证只是为了尽早地辨识输入错误，起到提高UI体验的作用。

Web 应用端的输入值验证按 Web 应用内的处理则极有可能被误认为具有攻击性意义的代码。输入值验证通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策。

针对输出值做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。

##### 10.2.1 跨站脚本攻击

跨站脚本攻击(XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。

*XSS有可能造成的影响：*

+ 利用虚假输入表单骗取用户个人信息；
+ 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
+ 显示伪造的文章或图片。

**防御方案：**

1. 在输入方面对所有用户提交内容进行可靠的输入验证，提交内容包括URL、查询关键字、http头、post数据等
2. 在输出方面，在用户输内容中使用<XMP>标签。标签内的内容不会解释，直接显示。
3. 严格执行字符输入字数控制。
4. 在脚本执行区中，应绝无用户输入。

##### 10.2.2 SQL 注入攻击

SQL注入攻击是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。

*SQL注入攻击有可能造成的影响：*

+ 非法查看或篡改数据库内的数据
+ 规避认证
+ 执行和数据库服务器业务关联的程序等。

**防御方案：**

1. 绑定变量，采用预编译语句集(PreparedStatement)，它内置了处理SQL注入的能力。
2. 使用存储过程，调用过程中直接传入参数。
3. 使用正则表达式对传入的参数进行过滤。

##### 10.2.3 OS 命令注入

OS 命令注入攻击是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要能调用 Shell 函数的地方就有存在被攻击的风险。

OS 命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序。

**防御方案：**

1. 尽量减少命令执行函数的使用，并在disable_functions中禁用；
2. 在进入命令执行的函数或方法之前，对参数进行过滤；
3. 参数的值尽量使用引号包裹，并在拼接前调用 addslashes 进行转义。

##### 10.2.4 HTTP 首部注入攻击

HTTP 首部注入攻击是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。

向首部主体添加内容的攻击称为HTTP响应截断攻击。

*HTTP首部注入攻击可能造成的影响：*

+ 设置任何的 Cookie 信息
+ 重定向至任意 URL
+ 显示任意的主体(HTTP响应截断攻击)

另外，滥用 HTTP/1.1 中汇集多响应返回功能，会导致缓存服务器对任意内容进行缓存操作。这种攻击称为缓存污染。

使用缓存服务器的用户，在浏览器遭受攻击的网站时，会不断浏览被替换掉的Web网页。

##### 10.2.5 邮件首部注入攻击

邮件首部注入攻击是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或病毒。

##### 10.2.5 目录遍历攻击

目录遍历攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历攻击。

##### 10.2.6 远程文件包含漏洞

远程文件包含漏洞是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。

#### 10.3 因设置或设计上的缺陷引发的安全漏洞

##### 10.3.1 强制浏览

强制浏览安全漏洞是指，从安置在 Web 服务器的公开目录下得文件中，浏览那些原本非自愿公开的文件。

*强制浏览可能会造成一下影响：*

+ 泄露用户的个人信息等重要情报
+ 泄露原本需要具有访问权限的用户才可查阅的信息内容
+ 泄露未外连到外界的文件

##### 10.3.2 不正确的错误消息处理

不正确的错误消息处理的安全漏洞是指，Web 应用的错误信息内包含对攻击者有用的信息。

与 Web 应用有关的主要错误信息如下所示：

+ Web 应用抛出的错误消息
+ 数据库等系统抛出的错误消息

*Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。*

##### 10.3.3 开放重定向

开放重定向是一种对指定的任意 URL 作重定向跳转的功能。

#### 10.4 因会话管理疏忽而引发的安全漏洞

会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就回导致用户的认证状态被窃取等后果。

##### 10.4.1 会话劫持

会话劫持是指攻击者通过某种手段拿到用户的会话 ID，并非使用此会话 ID 伪装成用户，达到攻击的目的。

*几种攻击者可获得会话 ID的途径：*

+ 通过非正规的生成方法推测会话ID
+ 通过窃听或XSS攻击盗取会话ID
+ 通过会话固定攻击强行获取会话ID

##### 10.4.2 会话固定攻击

对以窃取目标会话ID为主动攻击手段的会话劫持而言，会话固定攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。

Session Adoption 是指 PHP 或 ASP.NET 能够接收处理未知会话ID的功能。

##### 10.4.3 跨站点请求伪造

跨站点请求伪造攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。

*跨站点请求伪造可能会造成一下影响：*

+ 利用已通过认证的用户权限更新设定信息等
+ 利用已通过认证的用户权限购买商品
+ 利用已通过认证的用户权限在留言板上发表言论

#### 10.5 其他安全漏洞

##### 10.5.1 密码破解

+ 通过网络的密码试错
+ 对已加密密码的破解

除去突破认证的攻击手段，还有 SQL 注入攻击逃避认证、跨站脚本攻击窃取密码信息等方法。

##### 10.5.2 点击劫持

点击劫持是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点解链接访问内容的一种攻击手段，又称为界面伪装。

##### 10.5.3 DoS攻击

DoS攻击是一种让运行中的服务呈停止状态的攻击。有时也叫作服务停止攻击或拒绝服务攻击。DoS攻击对象不仅限于 Web 网站，还包括网络设备及服务器等。

主要的DoS攻击方式：

+ 集中利用访问请求造成资源过载，资源耗尽的同时，实际上服务也就呈停止状态；
+ 通过攻击安全漏洞使服务停止。

集中利用访问请求的 DoS攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止 DoS 攻击。

多台计算机发起的 DoS 攻击称为 DDoS攻击。DDoS攻击通常利用那些感染病毒的计算机作为攻击者的跳板。

**防御方案：**

1. 备份网站，临时主页；
2. HTTP 请求拦截：封禁恶意 IP 段的请求，以及带有恶意User Agent 字段的请求；
3. 带宽扩容；
4. CDN。

**参考：[阮一峰·DDOS 攻击的防范教程](http://www.ruanyifeng.com/blog/2018/06/ddos.html)**

##### 10.5.4 后门程序

后门程序是指开发设置的隐藏入口，可不按正常的步骤使用受限功能，利用后门程序就能够使用原本限制的功能。

后门程序分为 3 种类型：

+ 开发阶段作为 Debug 调用的后门程序
+ 开发者为了自身利益植入的后门程序
+ 攻击者通过某种方法设置的后门程序