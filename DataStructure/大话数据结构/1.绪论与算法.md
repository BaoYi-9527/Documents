## 绪论

### 相关概念

+ **数据结构:** 是相互之间存在一种或多种特定关系的数据元素的集合。
+ *数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。*
+ **数据：** 是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。
+ **数据元素：** 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
+ **数据项：** 一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。
+ **数据对象：** 是性质相同的数据元素的集合，是数据的子集。
+ *不同数据元素之间不是独立的，而是存在特定的关系，这些关系被称为结构。*

#### 逻辑结构与物理结构

**逻辑结构：** 是指数据对象中数据元素之间的相互关系。
+ 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。
+ 线性结构：线性结构中的数据元素之间是一对一的关系。
+ 树形结构：树形结构的数据元素之间存在一种一对多的层次关系。
+ 图形结构：图形结构的数据元素是多对多的关系。

**物理结构：** 是指数据的逻辑结构在计算机中的存储形式。
+ 顺序存储结构：是指把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的。
+ 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

#### 抽象数据类型

**数据类型：** 是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

> 在 C 语言中，按照取值的不同，数据类型可以分为俩类：
> + 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。
> + 结构类型：由若干个类型组合而成，是可以再分解的。例如：整型数组是由若干整型数据组成的。
> 抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。

**抽象数据类型(ADT)：** 是指一个数学模型及定义在改模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。
+ 抽象的意义在于数据类型的数学抽象特性；
+ 抽象数据类型不仅仅指哪些已经定义并实现的数据类型，还可以是程序员在设计软件程序时自己定义的数据类型；
+ 一个抽象数据类型定义了：一个数据对象、数据对象中各数据元素之间的关系以及对数据元素的操作。
+ *抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。*

## 算法

*算法是解决特定问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作。*

### 算法的特性

**算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。**

1. *算法具有零个或多个输入。算法至少有一个或多个输出。*
2. *有穷性：指算法在执行优先的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成。*
3. *确定性：算法的每一步都具有确定的含义，不会出现二义性。*
4. *可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。*

### 算法设计的要求

1. *正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求，能够得到问题的正确答案。*
2. *可读性：算法设计的另一目的是为了便于阅读、理解与交流。*
3. *健壮性：当输入数据不合法时，算法也能够做出相关处理，而不是产生异常或莫名其妙的结果。*
4. *好的算法还应该具备时间效率高和存储量低的特点。*

### 算法效率的度量方法

**事后统计方法：** 通过设计好的测试程序和数据(单元测试)，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
**事前分析估算方法：** 在计算机程序编制前，依据统计方法对算法进行估算。

*程序在计算机上运行时所消耗的时间取决于下列因素：*
1. 算法采用的策略、方法；
2. 编译产生的代码质量；
3. 问题输入的规模；
4. 机器执行指令的速度。

> 也就是说，抛开与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题的输入规模是指输入量的多少。
> 在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。

### 函数的渐进增长

> 函数的渐近增长：给定俩个函数 `f(n)` 和 `g(n)`，如果存在一个整数 N，使得对于所有的 n > N，`f(n)` 总是比 `g(n)` 大，那么我们说 `f(n)` 的增长渐进快于 `g(n)`。

*算法例子：* 
+ `f(n) = 2n + 3`
+ `f(n) = 2n^2 + 1`
+ `f(n) = 2n^2 + 3n + 1`
+ `f(n) = 2n^3 + 3n + 1`

对于这些算法，随着 `n` 的增长，我们可以忽略这些加法常数，以及与最高次项相乘的常数在 `n` 的增长过程中也开始变得不重要。
随着 `n` 的增长，最高次项的指数大的，函数随着 `n` 的增长，结果也会变得增长特别快。

*结论：*
+ *判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高项)的阶数。*
+ *某个算法，随着 `n` 的增大，它会越来越优于另一算法，或者越来越差于另一算法。*

### 算法时间复杂度

#### 算法时间复杂度定义

> 在进行算法分析时，语句总的执行次数 `T(n)` 是关于问题规模 `n` 的函数，进而分析 `T(n)` 随 `n` 的变化情况并确定 `T(n)` 的数量级。
> 算法的时间复杂度，也就是算法的时间量度，记作：`T(n) = O(f(n))` 。
> 它表示随问题规模 `n` 的增大，算法执行时间的增长率和 `f(n)` 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。
> 其中 `f(n)` 是问题规模 `n` 的某个函数。而这种用大写 `O()` 来体现算法时间复杂度的记法，称之为 *大O记法* 。

#### 推导大O阶方法

1. *用常数 1 取代运行时间中的所有加法常数。*
2. *在修改后的运行次数函数中，只保留最高阶项。*
3. *如果最高阶项存在且不是 1，则去除与这个项相乘的常数。*
4. *得到的结果就是大 O 阶。*

**常见的时间复杂度**

| 执行次数函数 | 阶 | 非正式术语 |
| ---------- | --- | ------- |
| 12 | O(1) | 常数阶 |
| 2n+3 | O(n) | 线性阶 |
| 3n<sup>2</sup>+2n+1 | O(n<sup>2</sup>) | 平方阶 |
| 5log<sub>2</sub>n+20 | O(logn) | 对数阶 |
| 2n+3nlog<sub>2</sub>n+19 | O(nlogn) | nlogn阶 |
| 6n<sup>3</sup>+2n<sup>2</sup>+3n+4 | O(n<sup>3<sup>) | 立方阶 |
| 2<sup>n</sup> | O( 2<sup>n</sup>) | 指数阶 |

*常用时间复杂度所耗费时间从小到大依次是：*
 O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)


### 最坏情况与平均情况

> 最坏情况运行时间是一种保证，那就是运行时间不能再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏的运行时间。
> 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

### 空间复杂度

> 算法的空间复杂度通过计算算法和所需的存储空间实现，算法空间复杂度记作 `S(n) = O(f(n))`。其中， `n` 为问题的规模，`f(n)` 为语句关于 `n` 所占存储空间的函数。

























